<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nogine Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="getting_started/creating_a_window.html"><strong aria-hidden="true">1.</strong> Creating a Window</a></li><li class="chapter-item expanded "><a href="getting_started/main_loop.html"><strong aria-hidden="true">2.</strong> Creating the Main Loop</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/main_loop/forcing_framerate.html"><strong aria-hidden="true">2.1.</strong> Forcing Framerate</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Basic Graphics</li><li class="chapter-item expanded "><a href="basic_graphics/setup.html"><strong aria-hidden="true">3.</strong> Graphics Setup</a></li><li class="chapter-item expanded "><a href="basic_graphics/about.html"><strong aria-hidden="true">4.</strong> About the Rendering System</a></li><li class="chapter-item expanded "><a href="basic_graphics/primitive_rendering.html"><strong aria-hidden="true">5.</strong> Primitive Rendering</a></li><li class="chapter-item expanded "><a href="basic_graphics/texture_rendering.html"><strong aria-hidden="true">6.</strong> Texture Rendering</a></li><li class="chapter-item expanded "><a href="basic_graphics/sprites.html"><strong aria-hidden="true">7.</strong> Sprites and Sprite Atlases</a></li><li class="chapter-item expanded affix "><li class="part-title">User Input</li><li class="chapter-item expanded affix "><li class="part-title">Audio Playing</li><li class="chapter-item expanded "><a href="audio/playing.html"><strong aria-hidden="true">8.</strong> Playing Audio</a></li><li class="chapter-item expanded "><a href="audio/channels.html"><strong aria-hidden="true">9.</strong> Audio Channels</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Graphics</li><li class="chapter-item expanded "><a href="adv_graphics/custom_meshes.html"><strong aria-hidden="true">10.</strong> Custom Meshes</a></li><li class="chapter-item expanded "><a href="adv_graphics/custom_materials.html"><strong aria-hidden="true">11.</strong> Custom Materials</a></li><li class="chapter-item expanded "><a href="adv_graphics/custom_render_pipeline.html"><strong aria-hidden="true">12.</strong> Custom Render Pipeline</a></li><li class="chapter-item expanded "><a href="adv_graphics/performance.html"><strong aria-hidden="true">13.</strong> Performance Considerations</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Nogine Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong><a href="https://github.com/JustMel69/nogine">Nogine</a></strong> is a 2D Game Development framework made in pure Rust.</p>
<p>One of the main design principles in <strong>Nogine</strong> is minimizing the number of dependencies that need to be compiled in order for it to work.</p>
<p>(This book assumes you have basic proeficiency with the Rust programming language. If you don't, check out the <a href="https://doc.rust-lang.org/stable/book/">Rust Book</a>)</p>
<p>(This book also assumes you have some experience with game development)</p>
<h1 id="warning"><a class="header" href="#warning">Warning</a></h1>
<p><strong>Nogine</strong> quite literally has just come out of the oven, so bugs, performance issues and poor design is to be expected. It is not recommended to build any serious long term project with it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-window"><a class="header" href="#creating-a-window">Creating a Window</a></h1>
<p>Creating a window in <strong>Nogine</strong> revolves around a <code>WindowCfg</code> object. This object defines the initial configuration of your window, following the <a href="https://en.wikipedia.org/wiki/Builder_pattern">builder pattern</a>.</p>
<p><code>WindowCfg</code> allows to set these initial parameters:</p>
<ul>
<li><strong>Resolution</strong> through the <code>.res()</code> method.</li>
<li><strong>Title</strong> thorugh the <code>.title()</code> method.</li>
<li><strong>Window mode</strong> through the <code>.mode()</code> method.</li>
</ul>
<p>First, we'll create a <code>WindowCfg</code> object.</p>
<pre><code class="language-rust ignore">use nogine::window::{WindowMode, WindowCfg};

fn main() {
    let window_cfg = WindowCfg::default()
        .res((1280, 720))
        .title(&quot;Hello Window!&quot;)
        .mode(WindowMode::Fullscreen);
}</code></pre>
<p>Once we have our <code>WindowCfg</code>, we can initialize the window by calling the <code>.init()</code> method. This method will return an instance of the <code>Window</code> type with the provided configuration.
To prevent the application from closing, we'll add a <code>loop {}</code> after creating the window.</p>
<pre><code class="language-rust ignore">use nogine::window::{WindowMode, WindowCfg};

fn main() {
    let window_cfg = WindowCfg::default()
        .res((1280, 720))
        .title(&quot;Hello Window!&quot;)
        .mode(WindowMode::Fullscreen);

    let window = window_cfg.init().expect(&quot;Couldn't open the window.&quot;);

    loop {};
}</code></pre>
<p>If you execute the code now, you'll find that the window will not behave properly. This is normal as we are not currently handling any window event, but we'll address it in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-main-loop"><a class="header" href="#creating-the-main-loop">Creating the Main Loop</a></h1>
<p>The <strong>main loop</strong> of an application is, as its name implies, the loop that handles the logic that must be constantly executed.</p>
<p>Luckily for us, <strong>Nogine</strong> automatically handles most of the main loop handling, so the required setup is minimal. A basic main loop in <strong>Nogine</strong> works like so:</p>
<pre><code class="language-rust ignore">use nogine::window::{WindowMode, WindowCfg};

fn main() {
    let window_cfg = WindowCfg::default()
        .res((1280, 720))
        .title(&quot;Hello Window!&quot;)
        .mode(WindowMode::Fullscreen);

    let mut window = window_cfg.init().expect(&quot;Couldn't open the window.&quot;);

    while window.is_running() {
        window.pre_tick(None);
        window.post_tick();
    }
}</code></pre>
<p>In case you are wondering why the first parameter of the <code>.pre_tick()</code> method is <code>None</code>, this will be answered in the <a href="getting_started/../adv_graphics/custom_render_pipeline.html">Custom Render Pipeline</a> chapter, but there's no need to worry about that currently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forcing-framerate"><a class="header" href="#forcing-framerate">Forcing Framerate</a></h1>
<p>Something related to the main loop is forcing a framerate. This is actually desirable in many cases to reduce the strain on CPU and GPU resources.</p>
<p>The <code>Window</code> type comes with a <code>.set_target_framerate()</code> exactly for this.</p>
<p>To lock the framerate at 60 fps we would do something like this:</p>
<pre><code class="language-rust ignore">use nogine::window::{WindowMode, WindowCfg};

fn main() {
    // --snip--

    window.set_target_framerate(Some(60.0));

    while window.is_running() {
        window.pre_tick(None);

        // Game logic here

        window.post_tick();
    }
}</code></pre>
<h2 id="obtaining-the-timestep"><a class="header" href="#obtaining-the-timestep">Obtaining the Timestep</a></h2>
<p>Forcing the framerate only guarantees it not <strong>exceding</strong> the target framerate, but on lower end devices or poorly optimized games the framerate may be much less than the target.</p>
<p>For this very reason, it is desirable to have a <code>time_step</code> variable. Luckily, the <code>Window</code> type already handles that for us and allows us to retrieve the time step through the <code>.ts()</code> method.</p>
<pre><code class="language-rust ignore">use std::time::Instant;

use nogine::window::{WindowMode, WindowCfg};

fn main() {
    // --snip--

    window.set_target_framerate(Some(60.0));
    while window.is_running() {
        window.pre_tick(None);

        let ts = window.ts();

        // Game logic here

        window.post_tick();
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphics-setup"><a class="header" href="#graphics-setup">Graphics Setup</a></h1>
<p>To start displaying graphics, some setup is necessary to ensure the rendered data will display properly.</p>
<p>We will setup the following parameters before continuing:</p>
<ul>
<li><a href="basic_graphics/setup.html#pixels-per-unit">Pixels per unit</a>.</li>
<li><a href="basic_graphics/setup.html#camera-data">Camera data</a>.</li>
<li><a href="basic_graphics/setup.html#clear-color">Clear color</a>.</li>
</ul>
<h2 id="pixels-per-unit"><a class="header" href="#pixels-per-unit">Pixels per Unit</a></h2>
<p><strong>Pixels per unit</strong> (PPU) defines the number of pixels that fit inside a &quot;spatial unit&quot;. <strong>PPU</strong> can be set at any time, and the associated functions are the following:</p>
<pre><code class="language-rust ignore">Graphics::set_pixels_per_unit // Sets the current pixels per unit
Graphics::get_pixels_per_unit // Returns the current pixels per unit</code></pre>
<h2 id="camera-data"><a class="header" href="#camera-data">Camera Data</a></h2>
<p>The <strong>camera data</strong> defines which objects will be viewed by the camera, and therefore, be rendered. Camera data can be set with the following function:</p>
<pre><code class="language-rust ignore">Graphics::set_cam(pos, half_size) // Schedules a camera change
Graphics::get_cam_data // Returns the current camera data</code></pre>
<p>In most cases, <code>half_size</code> should follow the window's aspect ratio. The aspect ratio can be obtained with the <code>.get_aspect_ratio()</code> method.</p>
<p>Because the aspect ratio may change if the player changes the window size, you should set the camera data every frame.</p>
<h2 id="clear-color"><a class="header" href="#clear-color">Clear Color</a></h2>
<p>The <strong>clear color</strong> is the color of the screen background. The functions associated with clear color are the following:</p>
<pre><code class="language-rust ignore">Graphics::set_clear_col // Sets the clear color
Graphics::get_clear_col // Returns the clear color</code></pre>
<p>You only need to run the set function once, so you can do it before the main loop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-the-rendering-system"><a class="header" href="#about-the-rendering-system">About the Rendering System</a></h1>
<p>The rendering system in <strong>Nogine</strong> works like a state machine, so always keeping a mental note on the state is key to avoid undesired behavior.</p>
<p>The rendering part is composed of a <a href="https://www.gamedev.net/tutorials/programming/graphics/opengl-batch-rendering-r3900/">Batch Rendering System</a> that stores the state of the rendering system when a render request is performed. These are all the elements that compose the state of the rendering system:</p>
<ul>
<li><strong>Camera Data:</strong> This value will be consistent across the whole frame, all changed done the the camera data will only come into effect after the frame has ended.</li>
<li><strong><a href="basic_graphics/../adv_graphics/custom_materials.html">Custom Materials</a>:</strong> These values will change in an intuitive way. Any geometry rendered between setting and resetting the custom material will be rendered with said material.</li>
<li><strong>Geometry Type:</strong> These values will change automatically when scheduling the rendering of different kinds of items. Keep in mind that only the same type of geometry can be batched, we will go more in depth in the <a href="basic_graphics/../adv_graphics/performance.html">Performance Considerations</a> chapter.</li>
<li><strong>Blending Modes:</strong> Different blending modes can be set and reset at will.</li>
</ul>
<p>Drawing functions only apply to the current frame, so to consistently draw a piece of geometry the drawing function must be called each frame.</p>
<h2 id="function-names"><a class="header" href="#function-names">Function names</a></h2>
<p>All graphics related functions are static methods of the <code>Graphics</code> type. Most drawing functions have a simplified version, and an extended version suffixed with an <code>_ext</code> or a <code>_full</code> in its name.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-rendering"><a class="header" href="#primitive-rendering">Primitive Rendering</a></h1>
<p>Rendering primitives in <strong>Nogine</strong> is as simple as calling the <em>associated draw function</em>.</p>
<p>These are the available primitives and their draw functions:</p>
<ul>
<li><strong>Rects:</strong> <code>::draw_rect()</code> and <code>::draw_rect_full()</code>.</li>
<li><strong>Circles:</strong> <code>::draw_circle()</code> and <code>::draw_ellipse()</code>.</li>
<li><strong>Polygons:</strong> <code>::draw_polygon()</code> and <code>::draw_polygon_ext()</code>.</li>
</ul>
<p>Now, with the following configuration you should get something like the following image:</p>
<pre><code class="language-rust ignore">Graphics::set_cam(Vector2::ZERO, Vector2(1.5 * window.aspect_ratio(), 1.5));

Graphics::draw_rect(Vector2(-1.55, -0.5), Vector2::ONE, Color4::CYAN);
Graphics::draw_circle(Vector2::ZERO, 0.5, Color4::YELLOW);
Graphics::draw_polygon(Vector2(1.0, 0.0), 0.5, 0.0, 6, Color::PINK);</code></pre>
<p><img src="basic_graphics/../assets/primitives.png" alt="A cyan square, a yellow circle and a pink hexagon" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="texture-rendering"><a class="header" href="#texture-rendering">Texture Rendering</a></h1>
<h2 id="loading-a-texture"><a class="header" href="#loading-a-texture">Loading a Texture</a></h2>
<p>Before rendering a texture, it's necessary to load it from disk or from memory. To do this, we'll use the <code>::load()</code> method from the <code>Texture</code> type. This method accepts a <strong>reader</strong> and a configuration and returns a <code>Result&lt;Texture, _&gt;</code>.</p>
<p>For example, we could do something like this:</p>
<pre><code class="language-rust ignore">let file = File::open(&quot;texture.png&quot;).unwrap();
let buf_reader = BufReader::new(file);
let texture = Texture::load(&amp;buf_reader, Default::default()).unwrap();</code></pre>
<h3 id="texture-configs"><a class="header" href="#texture-configs">Texture Configs</a></h3>
<p>To customize how our texture will be sampled, we'll need to specify the <strong>configuration</strong> when loading the texture through the <code>TextureCfg</code> type. This type allows us to configure the following fields:</p>
<ul>
<li><strong>Filtering:</strong> Defines the interpolation used to sample the pixels from the texture. (Closest/Nearest, linear...)</li>
<li><strong>Wrapping:</strong> Defines how the sampler will behave when trying to load outside the 0 to 1 uv range (outside the bounds of the texture).</li>
</ul>
<h2 id="rendering-the-texture"><a class="header" href="#rendering-the-texture">Rendering the Texture</a></h2>
<p>To render textures we can use the functions <code>::draw_texture()</code> and <code>::draw_texture_full()</code>. The size of the texture will depend on the <a href="basic_graphics/./setup.html#pixels-per-unit">pixels per unit</a> and will keep its aspect ratio, unless it's explicitly scaled.</p>
<p>For example, this is the code we would use to render the texture we previously loaded into the screen:</p>
<pre><code class="language-rust ignore">let file = File::open(&quot;texture.png&quot;).unwrap();
let buf_reader = BufReader::new(file);
let texture = Texture::load(&amp;buf_reader, Default::default()).unwrap();

Graphics::draw_texture(Vector2::ZERO, Vector2::ONE, 0.0, &amp;texture);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprites-and-sprite-atlases"><a class="header" href="#sprites-and-sprite-atlases">Sprites and Sprite Atlases</a></h1>
<p>There are 3 key concepts regarding <strong>Sprites</strong>:</p>
<ul>
<li><strong>Sprites:</strong> A slice of a texture.</li>
<li><strong>Sprite Atlases:</strong> A texture containing multiple sprites.</li>
<li><strong>Sprite Rects:</strong> The rect that defines a Sprite inside a Sprite Atlas.</li>
</ul>
<h2 id="defining-a-sprite-atlas"><a class="header" href="#defining-a-sprite-atlas">Defining a Sprite Atlas</a></h2>
<p>Sprite Atlases in <strong>Nogine</strong> are defined by two things, an <em>internal texture</em> and a <em>cell size</em>.</p>
<p>Sprite Atlases are organized in a grid of cells. A cell is the minimum size a Sprite from that atlas can have, and all Sprites are made up of an integer number of cells.</p>
<p>This means you can have, for example, 16x16 Sprites and 32x32 Sprites in the same sprite atlas by having a cell size of 16.</p>
<p>Sprite Atlases are created as such:</p>
<pre><code class="language-rust ignore">use nogine::graphics::texture::SpriteAtlas;

let atlas = SpriteAtlas::new(texture, (16, 16));</code></pre>
<h2 id="getting-sprites"><a class="header" href="#getting-sprites">Getting Sprites</a></h2>
<p>To get a sprite from the atlas, you'll need a <strong>Sprite Rect</strong>.</p>
<p>Sprite Rects are defined by a position and a size, both in cells. (Positions go from top to bottom and left to right).</p>
<p>Sprites can be extracted from an atlas as such:</p>
<pre><code class="language-rust ignore">use nogine::graphics::texture::SprRect;

let spr_a = atlas.get(SprRect(0, 0, 1, 1)); // A 1x1 sprite
let spr_b = atlas.get(SprRect(1, 0, 2, 2)); // A 2x2 sprite</code></pre>
<h3 id="some-considerations"><a class="header" href="#some-considerations">Some Considerations</a></h3>
<p><strong>Sprites</strong> contain a reference to their Sprite Atlas, and as such they require a lifetime. If you need to store Sprites, it is simpler to store the Sprite Rect and the Sprite Atlas instead of the sprite itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="playing-audio"><a class="header" href="#playing-audio">Playing Audio</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-channels"><a class="header" href="#audio-channels">Audio Channels</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-meshes"><a class="header" href="#custom-meshes">Custom Meshes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-materials"><a class="header" href="#custom-materials">Custom Materials</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-render-pipeline"><a class="header" href="#custom-render-pipeline">Custom Render Pipeline</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
